// ! Moe Counter

use macro_toolset::{
    str_concat,
    string::{NumStr, StringT},
};
use rand::Rng;

use crate::utils;

include!(concat!(env!("OUT_DIR"), "/moe-counter.rs"));

#[derive(Debug)]
/// Greeting data
pub(crate) struct MoeCounterImpl<'i> {
    /// Theme name, default: "moebooru"
    pub theme: &'i str,

    /// Length of number, default: 7
    pub padding: u8,

    /// Vertical offset, default: 0
    pub offset: f32,

    /// Align, default: "top"
    pub align: &'i str,

    /// Scale, default: 1.0, range: 0.2-2.0
    pub scale: f32,

    /// pixelated, 0 or 1
    pub pixelated: bool,

    /// Dark Mode, default: auto
    pub darkmode: Option<bool>,

    // Unusual Options
    /// Prefix number
    pub prefix: Option<u64>,
}

impl Default for MoeCounterImpl<'_> {
    fn default() -> Self {
        Self {
            theme: "moebooru",
            padding: 7,
            offset: 0.0,
            align: "top",
            scale: 1.0,
            pixelated: false,
            darkmode: None,
            prefix: None,
        }
    }
}

impl MoeCounterImpl<'_> {
    /// Generate SVG
    pub(crate) fn generate(self, count: u64) -> String {
        let moe_counter_list::MoeCounter {
            pics,
            pic_start,
            pic_end,
            size_w,
            size_h,
        } = self.get_moe_counter();

        let (size_w, size_h) = (size_w as f32 * self.scale, size_h as f32 * self.scale);

        let y = size_h;

        let image_start = pic_start.map(|pic| {
            (
                r#"<image id="start" width=""#,
                size_w,
                r#"" height=""#,
                size_h,
                r#"" xlink:href=""#,
                pic,
                r#"" />"#,
            )
        });

        let images_number_vec = {
            let mut numbers_dight = Vec::new();

            // Prefix, but does it make sense?
            self.prefix.encode_to_buf(&mut numbers_dight);

            macro_rules! impl_const_resize_set {
                ($($n:expr), *) => {
                    match self.padding {
                        $($n => NumStr::new_default(count).set_resize_len::<$n>().encode(&mut numbers_dight),)*
                        _ => NumStr::new_default(count).set_resize_len::<7>().encode(&mut numbers_dight),
                    }
                };
            }

            impl_const_resize_set!(
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
            );

            numbers_dight.iter_mut().for_each(|d| {
                *d -= b'0';
            });

            numbers_dight
        };

        let images_number = images_number_vec
            .iter()
            .map(|&dight| {
                (
                    r#"<image id=""#,
                    dight,
                    r#"" width=""#,
                    size_w,
                    r#"" height=""#,
                    size_h,
                    r#"" xlink:href=""#,
                    pics[dight as usize],
                    r#"" />"#,
                )
            })
            .collect::<Vec<_>>();

        let image_end = pic_end.map(|pic| {
            (
                r#"<image id="start" width=""#,
                size_w,
                r#"" height=""#,
                size_h,
                r#"" xlink:href=""#,
                pic,
                r#"" />"#,
            )
        });

        let style = (
            if self.pixelated {
                Some("image-rendering: pixelated;")
            } else {
                None
            },
            match self.darkmode {
                Some(true) => Some("filter: brightness(.6);"),
                Some(false) => None,
                None => {
                    Some("@media (prefers-color-scheme: dark) { svg { filter: brightness(.6); } }")
                }
            },
        );

        let x = (size_w + self.offset)
            * (images_number.len() as f32
                + if pic_start.is_some() { 1.0 } else { 0.0 }
                + if pic_end.is_some() { 1.0 } else { 0.0 });

        let mut x_offset = 0.0;
        let y_offset = if self.align == "center" {
            Some((y - size_h) / 2.0)
        } else if self.align == "bottom" {
            Some(y - size_h)
        } else {
            None
        };

        let y_offset = y_offset.map(|y_offset| (r#" y=""#, y_offset, '"'));

        str_concat!(
            r#"<?xml version="1.0" encoding="UTF-8"?><!-- Generated by "#,
            utils::VERSION,
            r#"-->"#,
            r#"<svg viewBox="0 0 "#,
            x,
            r#" "#,
            y,
            r#"" width=""#,
            x,
            r#"" height=""#,
            y,
            r#"" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">"#,
            r#"<title>Moe Counter!</title>"#,
            r#"<style>"#,
            style,
            r#"</style>"#,
            r#"<defs>"#,
            image_start,
            images_number,
            image_end,
            r#"</defs>"#,
            r#"<g>"#,
            {
                (
                    pic_start.map(|_| {
                        let r = (
                            r##"<use x=""##,
                            x_offset,
                            '"',
                            y_offset,
                            r##" xlink:href="#start" />"##,
                        );
                        x_offset += size_w + self.offset;
                        r
                    }),
                    images_number_vec
                        .iter()
                        .map(|dight| {
                            let r = (
                                r##"<use x=""##,
                                x_offset,
                                '"',
                                y_offset,
                                r##" xlink:href="#"##,
                                dight,
                                r##"" />"##,
                            );
                            x_offset += size_w + self.offset;
                            r
                        })
                        .collect::<Vec<_>>(), // Must collect here or compiler will complains
                    pic_end.map(|_| {
                        (
                            r##"<use x=""##,
                            x_offset,
                            '"',
                            y_offset,
                            r##" xlink:href="#end" />"##,
                        )
                    }),
                )
            },
            r#"</g></svg>"#
        )
    }

    fn get_moe_counter(&self) -> moe_counter_list::MoeCounter {
        let theme = if self.theme == "random" {
            moe_counter_list::THEMES_LIST
                [rand::rng().random_range(0..moe_counter_list::THEMES_LIST.len())]
        } else {
            self.theme
        };

        moe_counter_list::moe_counter_list(theme)
    }
}

// #[test]
// fn t() {
//     let data = MoeCounterImpl {
//         theme: "normal-1",
//         align: "center",
//         ..Default::default()
//     }
//     .generate(1234567890123);
//     std::fs::write("./test.svg", data);
// }
